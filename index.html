<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Spades Royal</title>
    <style>
        :root {
            --felt-color: #2e5e40;
            --card-width: 60px;
            --card-height: 84px;
            --radius: 8px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: radial-gradient(circle, #3a7550 0%, #1e3c29 100%);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            color: white;
        }

        /* --- UI Layout --- */
        #game-table {
            position: relative;
            flex-grow: 1;
            width: 100%;
            perspective: 1000px;
        }

        /* Player Positions */
        .player-area {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #top-player { top: 20px; width: 100%; flex-direction: column; }
        #left-player { left: 10px; top: 50%; transform: translateY(-50%); flex-direction: column; }
        #right-player { right: 10px; top: 50%; transform: translateY(-50%); flex-direction: column; }
        #user-player { bottom: 20px; width: 100%; height: 120px; z-index: 10; }

        /* Score & Info badges */
        .badge {
            background: rgba(0,0,0,0.4);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            margin: 4px;
            text-align: center;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        /* --- Card Styling --- */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border-radius: var(--radius);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            font-weight: bold;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: pointer;
            backface-visibility: hidden;
        }

        .card.red { color: #d00; }
        .card.black { color: #111; }
        
        /* Mini corners for cards */
        .card::before {
            content: attr(data-val) "\A" attr(data-suit);
            position: absolute;
            top: 4px;
            left: 4px;
            font-size: 12px;
            line-height: 10px;
            white-space: pre;
            text-align: center;
        }

        .card-back {
            background: linear-gradient(135deg, #1a2980 0%, #26d0ce 100%);
            border: 2px solid white;
        }
        
        /* Card Interactions */
        #user-hand {
            position: relative;
            width: 320px;
            height: 100%;
            margin: 0 auto;
        }

        #user-hand .card {
            top: -80px;
            transform-origin: bottom center;
        }

        #user-hand .card:active { transform: scale(1.1) translateY(-20px); }
        .playable-highlight { box-shadow: 0 0 10px 2px gold; }

        /* Played Cards (Center) */
        #trick-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            pointer-events: none;
        }

        /* --- Modals --- */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal.active { opacity: 1; pointer-events: auto; }

        .modal-content {
            background: white;
            color: #333;
            padding: 25px;
            border-radius: 16px;
            text-align: center;
            width: 80%;
            max-width: 300px;
        }

        .bid-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }
        
        button.nil { background: #FF3B30; grid-column: span 4; }
        
        #scoreboard {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 10px;
            z-index: 50;
        }
        
        /* Notifications */
        #message-toast {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            color: #111;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 60;
            white-space: nowrap;
        }
    </style>
</head>
<body>

<div id="scoreboard" class="badge">
    You/North: <span id="score-us">0</span> | West/East: <span id="score-them">0</span>
</div>

<div id="message-toast"></div>

<div id="game-table">
    <div id="top-player" class="player-area">
        <div class="badge">Partner <span id="bid-north"></span></div>
        <div id="north-hand" style="position:relative; width:40px; height:60px;"></div>
    </div>

    <div id="left-player" class="player-area">
        <div class="badge">West <span id="bid-west"></span></div>
        <div id="west-hand" style="position:relative; width:40px; height:60px;"></div>
    </div>

    <div id="right-player" class="player-area">
        <div class="badge">East <span id="bid-east"></span></div>
        <div id="east-hand" style="position:relative; width:40px; height:60px;"></div>
    </div>

    <div id="trick-area"></div>

    <div id="user-player" class="player-area">
        <div class="badge" style="position:absolute; top:-30px;">You <span id="bid-south"></span></div>
        <div id="user-hand"></div>
    </div>
</div>

<div id="bid-modal" class="modal">
    <div class="modal-content">
        <h2>Place Your Bid</h2>
        <div class="bid-grid" id="bid-buttons">
            </div>
    </div>
</div>

<div id="result-modal" class="modal">
    <div class="modal-content">
        <h2 id="round-result-title">Round Over</h2>
        <p id="round-result-details"></p>
        <button onclick="startNewRound()">Next Hand</button>
    </div>
</div>

<script>
    // --- Game Constants & State ---
    const SUITS = ['♠', '♥', '♣', '♦'];
    const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    
    let deck = [];
    let players = [[], [], [], []]; // 0: South(User), 1: West, 2: North, 3: East
    let hands = [[], [], [], []];
    let bids = [0,0,0,0];
    let tricksTaken = [0,0,0,0];
    let totalScore = { us: 0, them: 0 };
    
    let currentTurn = 0; // 0=User
    let currentTrick = [];
    let leadSuit = null;
    let spadesBroken = false;
    let roundOver = false;

    // --- DOM Elements ---
    const userHandEl = document.getElementById('user-hand');
    const trickArea = document.getElementById('trick-area');
    const bidModal = document.getElementById('bid-modal');
    const bidButtons = document.getElementById('bid-buttons');
    const toast = document.getElementById('message-toast');

    // --- Initialization ---
    function init() {
        createBidButtons();
        startNewRound();
    }

    function createBidButtons() {
        bidButtons.innerHTML = '';
        const nilBtn = document.createElement('button');
        nilBtn.innerText = "NIL (0)";
        nilBtn.className = 'nil';
        nilBtn.onclick = () => submitBid(0);
        bidButtons.appendChild(nilBtn);

        for(let i=1; i<=13; i++) {
            const btn = document.createElement('button');
            btn.innerText = i;
            btn.onclick = () => submitBid(i);
            bidButtons.appendChild(btn);
        }
    }

    function startNewRound() {
        document.getElementById('result-modal').classList.remove('active');
        deck = createDeck();
        shuffle(deck);
        deal();
        
        bids = [null, null, null, null];
        tricksTaken = [0,0,0,0];
        spadesBroken = false;
        roundOver = false;
        currentTrick = [];
        
        updateScoreboard();
        updateBidsUI();
        
        // Render empty bot hands (backs of cards)
        renderBotHand('west-hand', 13);
        renderBotHand('north-hand', 13);
        renderBotHand('east-hand', 13);
        
        renderUserHand();
        
        // Start Bidding Phase
        showBidModal();
    }

    // --- Deck Logic ---
    function createDeck() {
        let d = [];
        for(let s of SUITS) {
            for(let v=0; v<VALUES.length; v++) {
                d.push({ suit: s, value: VALUES[v], rank: v + 2, id: Math.random() });
            }
        }
        return d;
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function deal() {
        hands = [[], [], [], []];
        for(let i=0; i<52; i++) {
            hands[i % 4].push(deck[i]);
        }
        hands.forEach(h => sortHand(h));
    }

    function sortHand(hand) {
    // Check if Diamonds exist
    const hasDiamond = hand.some(c => c.suit === '♦');

    // Dynamic suit order
    const suitOrder = hasDiamond
        ? { '♠': 4, '♦': 3, '♣': 2, '♥': 1 }   // ♠ ♦ ♣ ♥
        : { '♠': 3, '♣': 2, '♥': 1 };          // ♠ ♣ ♥

    hand.sort((a, b) => {
        if (suitOrder[a.suit] !== suitOrder[b.suit]) {
            return suitOrder[b.suit] - suitOrder[a.suit];
        }
        return b.rank - a.rank;
    });
    }

    // --- Bidding ---
    function showBidModal() {
        bidModal.classList.add('active');
    }

    function submitBid(amount) {
        bids[0] = amount;
        bidModal.classList.remove('active');
        
        // Bots bid randomly based on strength (simplified)
        for(let i=1; i<4; i++) {
            bids[i] = calculateBotBid(hands[i]);
        }
        
        updateBidsUI();
        showMessage("Bids Placed. You Start.");
        currentTurn = 0; // User starts first hand (simplified rule)
        processTurn();
    }

    function calculateBotBid(hand) {
        let points = 0;
        hand.forEach(c => {
            if(c.rank >= 13) points++; // Aces
            if(c.rank >= 12 && c.suit === '♠') points++; // King of Spades
        });
        let bid = Math.max(1, points + Math.floor(Math.random() * 2));
        return Math.min(bid, 5); // Conservative bots
    }

    // --- Game Logic ---
    function processTurn() {
        if(roundOver) return;

        // If Trick is complete (4 cards)
        if (currentTrick.length === 4) {
            setTimeout(evaluateTrick, 1500);
            return;
        }

        if (currentTurn !== 0) {
            setTimeout(botPlay, 800);
        } else {
            highlightPlayableCards();
        }
    }

    function botPlay() {
        let hand = hands[currentTurn];
        let playable = getPlayableCards(hand);
        
        // Simple AI: play low if partner winning, high if not, or lowest valid
        let cardToPlay = playable[0]; 
        
        // Randomly pick a valid card for variety in this lite version
        // A real AI would check currentTrick to decide
        cardToPlay = playable[Math.floor(Math.random() * playable.length)];
        
        playCard(currentTurn, cardToPlay);
    }

    function getPlayableCards(hand) {
        if (currentTrick.length === 0) {
            // Leading
            if (spadesBroken) return hand;
            let nonSpades = hand.filter(c => c.suit !== '♠');
            return nonSpades.length > 0 ? nonSpades : hand;
        } else {
            // Following
            let following = hand.filter(c => c.suit === leadSuit);
            return following.length > 0 ? following : hand;
        }
    }

    function playCard(playerIndex, cardObj) {
        // Remove from hand
        hands[playerIndex] = hands[playerIndex].filter(c => c.id !== cardObj.id);
        
        // Update Logic
        if (currentTrick.length === 0) leadSuit = cardObj.suit;
        if (cardObj.suit === '♠') spadesBroken = true;

        currentTrick.push({ player: playerIndex, card: cardObj });

        // Visuals
        renderCardPlay(playerIndex, cardObj);
        
        if(playerIndex === 0) renderUserHand();
        else renderBotHand(getBotHandId(playerIndex), hands[playerIndex].length);

        currentTurn = (currentTurn + 1) % 4;
        processTurn();
    }

    function getBotHandId(idx) {
        if(idx===1) return 'west-hand';
        if(idx===2) return 'north-hand';
        return 'east-hand';
    }

    function evaluateTrick() {
        // Determine winner
        let winningPlay = currentTrick[0];
        
        currentTrick.forEach(play => {
            let isTrump = play.card.suit === '♠';
            let winnerIsTrump = winningPlay.card.suit === '♠';
            
            if (isTrump && !winnerIsTrump) {
                winningPlay = play;
            } else if (play.card.suit === winningPlay.card.suit && play.card.rank > winningPlay.card.rank && !(!isTrump && winnerIsTrump)) {
                winningPlay = play;
            }
        });

        let winnerIdx = winningPlay.player;
        tricksTaken[winnerIdx]++;
        
        // Visual Cleanup
        trickArea.innerHTML = '';
        currentTrick = [];
        leadSuit = null;
        
        updateBidsUI();
        
        // Check Round End
        if (hands[0].length === 0) {
            endRound();
        } else {
            currentTurn = winnerIdx;
            let winnerName = winnerIdx === 0 ? "You" : (winnerIdx === 2 ? "Partner" : "Opponent");
            showMessage(winnerName + " won the trick");
            processTurn();
        }
    }

    // --- Visual Rendering ---
    function renderUserHand() {
        userHandEl.innerHTML = '';
        let hand = hands[0];
        let width = 320;
        let overlap = 30;
        let totalW = hand.length * overlap;
        let startX = (width - totalW) / 2;

        hand.forEach((c, index) => {
            let el = createCardEl(c);
            el.style.left = (startX + (index * overlap)) + 'px';
            el.style.zIndex = index;
            
            el.onclick = () => {
                if(currentTurn === 0 && isCardPlayable(c)) {
                    playCard(0, c);
                }
            };
            
            userHandEl.appendChild(el);
        });
    }

    function isCardPlayable(card) {
        let validCards = getPlayableCards(hands[0]);
        return validCards.some(v => v.id === card.id);
    }

    function highlightPlayableCards() {
        let els = userHandEl.children;
        let validCards = getPlayableCards(hands[0]);
        for(let i=0; i<els.length; i++) {
            let cObj = hands[0][i];
            let isValid = validCards.some(v => v.id === cObj.id);
            if(isValid) {
                els[i].style.filter = "brightness(100%)";
                els[i].style.transform = "translateY(-10px)";
            } else {
                els[i].style.filter = "brightness(60%)";
                els[i].style.transform = "translateY(0)";
            }
        }
    }

    function renderBotHand(id, count) {
        let container = document.getElementById(id);
        container.innerHTML = '';
        // Just show a card back to represent count
        if(count > 0) {
            let back = document.createElement('div');
            back.className = 'card card-back';
            back.style.position = 'absolute';
            back.style.left = '0';
            back.style.top = '0';
            container.appendChild(back);
            
            let countBadge = document.createElement('div');
            countBadge.innerText = count;
            countBadge.style.cssText = "position:absolute; top:-10px; right:-10px; background:red; color:white; border-radius:50%; width:20px; height:20px; text-align:center; font-size:12px; line-height:20px;";
            container.appendChild(countBadge);
        }
    }

    function createCardEl(c) {
        let div = document.createElement('div');
        div.className = `card ${c.suit === '♥' || c.suit === '♦' ? 'red' : 'black'}`;
        div.innerHTML = c.suit; // Big Center Suit
        div.setAttribute('data-val', c.value);
        div.setAttribute('data-suit', c.suit);
        return div;
    }

    function renderCardPlay(playerIdx, c) {
        let el = createCardEl(c);
        trickArea.appendChild(el);
        
        // Positioning for animation entry
        // 0: Bottom, 1: Left, 2: Top, 3: Right
        let startX = 0, startY = 0;
        if(playerIdx === 0) startY = 200;
        if(playerIdx === 1) startX = -150;
        if(playerIdx === 2) startY = -200;
        if(playerIdx === 3) startX = 150;

        el.style.transform = `translate(${startX}px, ${startY}px) scale(0.5)`;
        
        // Force reflow
        void el.offsetWidth;

        // Animate to center
        let rotation = (Math.random() * 20) - 10;
        el.style.transform = `translate(0,0) scale(1) rotate(${rotation}deg)`;
        el.style.zIndex = currentTrick.length;
    }

    function updateBidsUI() {
        document.getElementById('bid-south').innerText = `(${tricksTaken[0]}/${bids[0] || '-'})`;
        document.getElementById('bid-west').innerText = `(${tricksTaken[1]}/${bids[1] || '-'})`;
        document.getElementById('bid-north').innerText = `(${tricksTaken[2]}/${bids[2] || '-'})`;
        document.getElementById('bid-east').innerText = `(${tricksTaken[3]}/${bids[3] || '-'})`;
    }
    
    function updateScoreboard() {
        document.getElementById('score-us').innerText = totalScore.us;
        document.getElementById('score-them').innerText = totalScore.them;
    }

    function showMessage(msg) {
        toast.innerText = msg;
        toast.style.opacity = 1;
        setTimeout(() => toast.style.opacity = 0, 2000);
    }

    // --- Scoring ---
    function endRound() {
        roundOver = true;
        let usTricks = tricksTaken[0] + tricksTaken[2];
        let usBid = bids[0] + bids[2];
        let themTricks = tricksTaken[1] + tricksTaken[3];
        let themBid = bids[1] + bids[3];

        let usRoundScore = calculateScore(usTricks, usBid);
        let themRoundScore = calculateScore(themTricks, themBid);
        
        totalScore.us += usRoundScore;
        totalScore.them += themRoundScore;

        document.getElementById('round-result-title').innerText = "Round Results";
        document.getElementById('round-result-details').innerHTML = 
            `You/Partner: Bid ${usBid}, Took ${usTricks} (+${usRoundScore})<br>` +
            `Opponents: Bid ${themBid}, Took ${themTricks} (+${themRoundScore})`;
            
        document.getElementById('result-modal').classList.add('active');
    }

    function calculateScore(taken, bid) {
        if (taken < bid) return - (bid * 10);
        let bags = taken - bid;
        return (bid * 10) + bags; // Simplified scoring (no bags penalty logic for brevity)
    }

    // Start
    init();

</script>
</body>
</html>
